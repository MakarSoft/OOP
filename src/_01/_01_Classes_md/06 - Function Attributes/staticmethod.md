
Декоратор `@staticmethod` в Python используется для определения статических методов в классе. Статические методы не принимают аргумент `self` и не имеют доступа к атрибутам экземпляра или класса. Они могут быть вызваны как на экземплярах класса, так и на самом классе.

Вот пример реализации простого декоратора `staticmethod`, чтобы продемонстрировать, как он работает:

### Реализация декоратора `staticmethod`

```python
class MyStaticMethod:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        return self.func

# Используем наш декоратор
def staticmethod(func):
    return MyStaticMethod(func)

# Пример использования
class MyClass:
    @staticmethod
    def my_static_method(x, y):
        return x + y

# Вызов статического метода
result = MyClass.my_static_method(5, 10)
print(result)  # Output: 15

# Также можно вызвать статический метод на экземпляре класса
obj = MyClass()
result_instance = obj.my_static_method(3, 7)
print(result_instance)  # Output: 10
```

### Объяснение кода

1. **Класс `MyStaticMethod`**: Это простой класс, который реализует метод `__get__`, позволяющий возвращать функцию, когда она вызывается. Это необходимо для того, чтобы декоратор работал корректно в контексте классов.

2. **Декоратор `staticmethod`**: Этот декоратор просто создает экземпляр `MyStaticMethod`, передавая ему функцию, которую нужно декорировать.

3. **Класс `MyClass`**: В этом классе мы используем декоратор `@staticmethod` для определения статического метода `my_static_method`, который принимает два аргумента и возвращает их сумму.

4. **Вызов статического метода**: Мы можем вызывать статический метод как на классе, так и на экземпляре класса, и в обоих случаях он будет работать одинаково.

### Заключение

Таким образом, мы реализовали простой декоратор `staticmethod`, который позволяет создавать статические методы в классах. В реальной библиотеке Python этот декоратор реализован более сложным образом, но основная идея остается той же.