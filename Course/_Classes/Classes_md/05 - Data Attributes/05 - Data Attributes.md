[05 - Data Attributes](https://github.com/fbaptiste/python-deepdive/blob/main/Part%204/Section%2002%20-%20Classes/05%20-%20Data%20Attributes.ipynb)

### Data Attributes

Давайте сначала сосредоточимся на атрибутах данных (невызываемых).

Как мы видели ранее, у нас могут быть атрибуты класса — они находятся в словаре класса:

```Python
class BankAccount:
    apr = 1.2
```

```Python
BankAccount.__dict__
```

```
mappingproxy({
	'__module__': '__main__',
    'apr': 1.2,
    '__dict__': <attribute '__dict__' of 'BankAccount' objects>,
    '__weakref__': <attribute '__weakref__' of 'BankAccount' objects>,
    '__doc__': None
})
```

```Python
BankAccount.apr
```

```
1.2
```

Теперь, когда мы создаем экземпляры этого класса:

```Python
acc_1 = BankAccount()
acc_2 = BankAccount()
```

Словари экземпляров в настоящее время пусты:

```Python
acc_1.__dict__, acc_2.__dict__
```

```
({}, {})
```

Словари экземпляров в настоящее время пусты: Тем не менее, эти экземпляры имеют атрибут `apr`:

```Python
acc_1.apr, acc_2.apr
```

```
(1.2, 1.2)
```

Откуда берется это значение? Класс, из которого были созданы объекты!

Фактически, если мы изменим атрибут класса:

```Python
BankAccount.apr = 2.5
```

Мы также увидим это отражение в примерах:

```Python
acc_1.apr, acc_2.apr
```

```
(2.5, 2.5)
```

А если мы добавим атрибут класса к `Банковский счет`:

```Python
BankAccount.account_type = 'Savings'
```

```Python
acc_1.account_type, acc_2.account_type
```

```
('Savings', 'Savings')
```

Как вы можете видеть, изменение атрибутов в **классе** также отражается в экземплярах — это происходит потому, что Python не находит атрибут `apr` в словаре экземпляров, поэтому далее он ищет в классе, который использовался для создания экземпляра.

Возникает вопрос: что произойдет, если мы добавим `apr` в словарь **экземпляров**?

```Python
acc_1.apr = 0
```

Ну, это не вызвало исключения — итак, что происходит сейчас:

```Python
acc_1.__dict__, acc_2.__dict__
```

```
({'apr': 0}, {})
```

Как вы можете видеть, мы фактически создаем запись для `apr` в словаре состояний `acc_1`.

Теперь, когда она у нас есть, если мы попытаемся получить значение атрибута `apr` для `acc_1`, Python найдет его в словаре экземпляров, поэтому он будет использовать его!

```Python
acc_1.apr, acc_2.apr
```

```
(0, 2.5)
```

По сути, атрибут экземпляра `apr` **скрывает** атрибут класса.

Вы также заметите, что `acc_2` **не** был затронут — это потому, что мы не изменили словарь `acc_2`, а только словарь для `acc_1`.

А функции `getattr` и `setattr` работают так же, как точечная нотация:

```Python
acc_1 = BankAccount()
print(acc_1.__dict__)
print(acc_1.apr)
print(getattr(acc_1, 'apr'))
```

```
{}
2.5
2.5
```

```Python
setattr(acc_1, 'apr', 0)
print(acc_1.__dict__)
print(acc_1.apr)
print(getattr(acc_1, 'apr'))
```

```
{'apr': 0}
0
0
```

Мы даже можем добавлять атрибуты экземпляра непосредственно к экземпляру:

```Python
acc_1.bank = 'Acme Savings & Loans'
```

```Python
acc_1.__dict__
```

```
{'apr': 0, 'bank': 'Acme Savings & Loans'}
```

Мы даже можем добавлять атрибуты экземпляра непосредственно к экземпляру: но это относится только к этому конкретному экземпляру:

```Python
acc_2 = BankAccount()
```

```
acc_2.__dict__
```

```
{}
```

Как вы можете видеть, `acc_2` имеет пустой словарь экземпляров.

Поэтому очень важно различать **атрибуты класса** и **атрибуты экземпляра**.

**Атрибуты класса** подобны атрибутам, которые являются «общими» для всех экземпляров, поскольку атрибут не находится в экземпляре, а находится в самом классе.

С другой стороны, **атрибуты экземпляра** специфичны для каждого экземпляра, и значения одного и того же атрибута могут быть разными в нескольких экземплярах, как мы только что видели с `acc_1.apr` и `acc_2.apr`.

Итак, вкратце, классы и экземпляры имеют свое собственное состояние, обычно поддерживаемое в словаре, доступном через `__dict__`. Независимо от того, где хранится состояние, когда мы ищем атрибут в экземпляре, Python сначала будет искать атрибут в локальном состоянии экземпляра. Если он не найдет его там, он будет искать его в классе экземпляра.

Еще одна вещь, которую следует отметить, — это разница в типе между классом и экземпляром `__dict__`.

Классы, как мы видели, возвращают объект `mapping proxy`:

```Python
BankAccount.__dict__
```

```
mappingproxy({
	'__module__': '__main__',
    'apr': 2.5,
    '__dict__': <attribute '__dict__' of 'BankAccount' objects>,
    '__weakref__': <attribute '__weakref__' of 'BankAccount' objects>,
    '__doc__': None,
    'account_type': 'Savings'
})
```

Но `instances`, возвращающие настоящий словарь:

```Python
acc_1.__dict__
```

```
{'apr': 0, 'bank': 'Acme Savings & Loans'}
```

Таким образом, с экземплярами, в отличие от классов, мы можем манипулировать этим словарем напрямую:

```Python
class Program:
    language = 'Python'
```

```Python
p = Program()
```

```Python
p.__dict__
```

```
{}
```

```Python
p.__dict__['version'] = '3.7'
```

```Python
p.__dict__
```

```
{'version': '3.7'}
```

```Python
p.version, getattr(p, 'version')
```

```
('3.7', '3.7')
```

Но опять же, это влияет только на этот конкретный **экземпляр**.

---

